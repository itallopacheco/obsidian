# ADR 001: Monorepo com Arquitetura de Microâ€‘serviÃ§os para Online Judge

**Data:** 2025-04-27  **Status:** #aceito

## Contexto e Problema

O sistema de Online Judge deve receber submissÃµes de cÃ³digo de forma assÃ­ncrona e permitir que:

- A **API de entrada** persista submissÃµes e publique mensagens de enfileiramento (fila).
    
- **Workers** consumam essa fila e deleguem a execuÃ§Ã£o ao serviÃ§o Piston.
    
- O **Piston Service** execute o cÃ³digo num ambiente isolado.
    

Para suportar picos de submissÃµes e variar a capacidade de processamento, Worker Service e Piston Service precisam escalar de maneira independente.

## DecisÃ£o

Adotar um **monorepo** contendo trÃªs mÃ³dulos Maven distintos:

1. **common/**
    
    - Biblioteca compartilhada contendo entidades de domÃ­nio, Value Objects, DTOs e interfaces (Ports) usadas por todos os serviÃ§os.
        
2. **ingress-service/**
    
    - ServiÃ§o Quarkus responsÃ¡vel por expor endpoints REST, persistir dados em Postgres e enfileirar submissÃµes.
        
3. **evaluation-service/**
    
    - ServiÃ§o Quarkus headless que consome filas (RabbitMQ/Kafka), faz HTTP POST para o Piston Service e atualiza resultados no banco.
        

AlÃ©m disso, o **Executor Service** roda como contÃªiner independente (imagem Docker oficial ou customizada), gerenciado por um Deployment e HPA prÃ³prio.

## Arquitetura

```mermaid
flowchart TD
  C[Client] -->|REST| API[Quarkus-API]
  subgraph Ingress Service
    API -->|write| DB[(Postgres)]
    API -->|"enqueue(submission_id)"| Q[(RabbitMQ/Kafka)]
  end

  subgraph Evaluation Service
    Q -->|"dequeue()"| W[Quarkus-Worker]
    W -->|POST /run| P[Piston Service]
    P -->|result| W
    W -->|update| DB
  end

  subgraph Executor Service
    P -->|containerized| Pods[Piston Pods ğŸ³]
  end

```

## ConsequÃªncias

### Vantagens

- **Desacoplamento**: Ingress, Evaluator e Executor escalam e sÃ£o deployados separadamente.
    
- **ConsistÃªncia**: `common` mantÃ©m um Ãºnico modelo de domÃ­nio e contratos.
    
- **CI/CD otimizado**: cada mÃ³dulo gera artefato e imagem Docker independente.
    
- **Observabilidade**: mÃ©tricas e health-checks especÃ­ficos por serviÃ§o.
    

### Desvantagens

- **Overhead de configuraÃ§Ã£o**: setup de monorepo, builds e pipelines para trÃªs mÃ³dulos.
    
- **GerÃªncia de versÃµes**: necessidade de versionar corretamente `common` e alinhar dependÃªncias.
    
- **Infra adicional**: broker de mensagens e orquestraÃ§Ã£o de mÃºltiplos Deployments.
    

---
